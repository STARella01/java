 		
 		컬렉션 프레임워크 Collection Frameworks : 자료구조형 데이터
 		
 		
 		
 		- 컬렉션은 배열과 유사하지만, 데이터 저장/조회/수정/삭제하는 작업을 쉽게 처리할 수 있으며,
 		  동적인 크기를 가지고 있다는 장점이 있습니다.
 		  - 컬렉션 계열은 Set / List / Map 등의 인터페이스가 있으며, 이를 구현한 클래스를 이용하면
 		  	객체들을 모음 저장할 수 있음. 		 
 		  	
 		  	
 		 [ 컬렉션 인터페이스의 하위 클래스 ]
 		 
 		 > Set 계열 
 		 	- Set 인터페이스를 구현한 클래스들 : HashSet, LinkedSet, TreeSet(자동정렬, 2진 알고리즘 사용)
 		 	- Set 계열은 순서가 없고, 중복을 허용하지 않는다. (순서가 없기 때문에 index 몇 번 불러오는 것이 가능)
 		 	ex) 123 과 234를 넣으면 중복되는 23은 사라지고 1234로 배열된다. / 수학의 집합과 같은 개념이라고 보면 됨.
 		 
 		 > List 계열
 		 	- List Interface를 구현한 클래스들 : ArrayList, LinkedList, Queue, Stack(Vector)
 		 	- 순서가 있고, 중복을 허용한다.
 		 	ex) 123 과 234를 넣으면 123234로 배열된다. 중복을 허용하기 때문에
 		 	
 		 > Map 계열 ( key값가지고 데이터 자료 맵핑(연결)해준다. ) - 사용하기 쉽다. 이미 만들어진 배열 사용하면 된다.
 		 	- Map Interface를 구현한 클래스들 : HashMap, TreeMap,  
 		 	
 		 	
	 	- 객체를 저장할 수 있는 자료구조들을 제공한다.
	 	- 컬렉션에 저장된 객체 (or 변수)들은 엘리먼트라고 한다.
	 	- 배열과 달리 동적인 공간을 갖는다.
	 	- 컬렉션마다 관리할 수 있는 메서드가 존재합니다.
	 	- 기존의 배열에 비해서 높은 성능을 보장하고 있다.
	 	
	 	- 자바 사용 이유 : 이런 컬렉션류가 있었기 때문에 프로그래밍 하기 쉬워서..
	 	
	 	
	 	참조
	 	[ Collection Interface의 주요 Method ]
	 	
	 	리턴 타입   	메서드
	 	boolean		add(E e)				E는 기본, 객체의 자료형을 / e는 객체 변수명, 컬렉션에 엘리먼트를 추가 - 추가 true , 안되면 false
	 	void			clear()					컬렉션의 모든 엘리먼트를 삭제
	 	boolean		contains(Object o)	컬렉션이 주어진 객체를 포함하면 true를 리턴
	 	boolean		isEmpty()				컬렉션이 비어 있으면 true를 리턴
	 	Iterater<E>	interator()			이 컬렉션의 interator 객체를 반환
	 	boolean		remove(Object 0)	주어진 엘리먼트 객체를 제거
	 	int				size					컬렉션의 엘리먼트 개수를 반환
	 	Object[]		toArray()				이 컬렉션의 모든 엘리먼트들을 배열로 반환
	 	<T> t[]		toArray(T[]	a)		이 컬렉션의 모든 엘리먼트들을 주어진 타입의 배열로 반환
	 	
	 	
	 	List 계열 ( 순서 O, 중복 O)
	 	- Lsit 컬렉션은 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동으로 인덱스 번호가 부여되고,
	 	인덱스를 통해서 객체를 검색, 삭제할 수 있는 기능을 제공하고 있음.
	 	
	 	-List는 객체를 순서대로 저장하며 동일한 객체를 중복 저장 할 수 있습니다.
	 	
	 	List의 주요 메서드 ****** 
	 	- 객체 추가 기능
	 	1. add (E e): 					주어진 객체를 List의 맨 끝부분에 추가
	 	2. add (int index, E e):			주어진 인덱스에 객체를 추가 ( add사용 시 추가 되면서 해당 부분에 있는 데이터는 뒷 순서로 밀림 )
	 	3. set	 (int index, E e):			주어진 인덱스에 저장된 객체를 주어진 객체로 바꿈
	 	
	 	- 객체 검색 기능
	 	1. contains(Object o):			주어진 객체가 저장되어 있는지 여부를 판단 (true or false)
	 	2. get(int index):				주어진 인덱스에 저장되어 있는 객체를 리턴
	 	3. isEmpty():						해당 컬렉션이 비어있는지 여부를 판단
	 	4. size():							저장되어 있는 전체 객체 수를 리턴.
	 	5. indexOf(Object o)			리스트에 주어진 객체의 위치를 반환 / 엘리먼트를 찾지 못한 경우 -1 반환
	 	
	 	- 객체 삭제 기능 / remove 객체 그 하나를 지움 , clear 전체 제거
	 	1. clear():							저장된 '모든 객체'를 삭제
	 	2. remove(int index)			주어진 인덱스에 저장된 객체를 삭제
	 	3. remove(Object o)			주어진 객체를 삭제. 		
		*******	 	
	 	
	 	
	 	[ Stack ] - 스택 위에서 아래로 순서대로 쌓이듯.
	 	- Stack은 List 컬렉션 클래스의 Vecter 클래스를 상속 받아 구현되어 있습니다.
	 	선입후출(Last in First out / 후입선출 - LIFO) - 마지막에 들어온 걸 먼저 내보낸다. 의 형태를 구현하여
	 	가장 나중에 저장된 데이터가 가장 먼저 나오게 됨.
	 	
	 	- 메서드
	 	리턴 타입			메서드
	 	boolean			empty()				스택이 비어있는지 확인. / 비어 있으면 true , 아니면 false
	 	E					peek()					스택의 제일 상단에 있는 요소를 반환
	 	E					pop()					스택의 제일 상단에 있는 요소를 반환하면서 삭제
	 	E					push()					스택의 제일 상단에 매개변수로 들어온 데이터를 저장.
	 	int					search(Object o)	스택에서 전달된 객체가 존재하는지 확인하고, 인덱스를 반환
													인덱스는 제일 상단위치에서 1부터 시작하여 반환됩니다.
													
	 	Queue
	 	
	 	- Queue는 스택과 다르게 인터페이스 형태로만 구현되어 있음.
	 	때문에 Queue는 직간접적으로 구현한 클래스가 상당히 많음. 그 중에 linked list 클래스가 있다.
	 		
 		- Queue 메모리 구조는 스택과 반대로 선입선출(FIFO)의 구조를 가지게 됨.
 		
	 	- Queue 메서드
	 	리턴 타입			메서드
	 	boolean			add(E e)				해당 큐의 맨 뒤(가장 늦게 저장된)에 전달된 매개변수를 삽입. 삽입되면 true , 공간이 없어 삽입이 안되는 경우 false
	 												IllegalStateException이 발생
	 	E					element()				해당 큐의 가장 앞에 있는 요소(가장 먼저 저장된)를 반환	
	 	boolean			offer(E e)				해당 큐의 맨 뒤에 전달된 매개변수를 삽입 // add랑 비슷
	 	
	 	E					peek()					해당 큐의 맨 앞에 있는 요소를 반환, 비어있으면 null 반환
	 	E					poll()					해당 큐의 맨 앞에 있는 요소를 반환하고 제거, 비어있으면 null 반환
		E					remove()				해당 큐의 맨 앞에 있는 요소를 제거
	 	
	 	
	 =======================================================
	 
 	 	Set 계열 ( 순서 X, 중복 X)
	 	- Set 컬렉션은 저장 순서를 보장하지 않으며, 객체의 중복 저장을 허용하지 않음.
	 	- Set 컬렉션은 인덱스로 관리하지 않으며, 들어갈 때의 순서와 나올 때의 순서가 다를 수 있음
	 	- Set 컬렉션은 인덱스로 객체를 검색하는 기능이 없고, 전체 객체를 대상으로 한 번 씩 반복해
	 	객체의 값을 가져오는 반복자( Iterator )를 제공한다.
	 	
	 	- Iterator 인터페이스의 주요 메서드
	 	1. hasNext()				가져올 객체가 있으면 true, 없으면 false를 리턴
	 	2. next()					컬렉션에서 하나의 객체를 가져옴.
	 	3. remove()				Set 컬렉션에서 객체를 제거함.
	 	
	 	Set 계열 컬렉션 주요 메서드
	 	
	 	- 객체 추가
	 	1. add(E e)				주어진 객체를 저장, 성공적으로 저장되면 true를 리턴, 중복 객체를 저장하면 false를 리턴ㄴ
	 		
	 	- 객체 검색
	 	1. contains(Object o)	주어진 객체가 저장되어 있는지 여부를 판단
	 	2. isEmpty()				컬렉션이 비어 있는지 조사
	 	3. iterator()				저장된 객체를 한 번씩 가져오는 반복자 객체를 리턴
	 	4. size()					저장되어 있는 전체 객체 수를 리턴
	 	
	 	- 객체 삭제
	 	1. clear()					저장된 모든 객체를 삭제
	 	2. remove(Object o)	주어진 객체를 삭제

===============================
	 	
	 	트리 구조 ( Tree , 나무구조 ) - 루트에서 가지 뻗어나가는 구조 - 자동정렬 기능 가지고 있음.
	 	- 그래프의 일종
	 	- 여러 노드가 한 노를 가리킬 수 없는 구조
	 	- 간단하게 회로가 없고, 서로 다른 두 노드를 잇는 길이 하나뿐인 그래프
	 	
	 	- 트리에는 최상위 노드를 루트 노드(root node 뿌리 노드)
	 	- 노드 A가 노드 B를 가리킬 대 A를 B의 부모 노드(Parent node)
	 	- 노드 B를 A의 자식 노드 (Child node)
	 	- 자식 노드가 없는 노드를 잎 노드(leaf node)
	 	- 앞 노드가 아닌 노드를 내브 노드(internal node)
	 	 	 	
	 	+++
	 	
	 	-List는 객체를 순서대로 저장하며 동일한 객체를 중복 저장 할 수 있습니다.	
	 	
 		  사용방법과 왜 사용하는지?를 알아야 함.	 
 		  
 		  배열은 처음에 하면 그 값이 정해져 있음 - 배열은 재활용성이 좋지 않다.
 		  배열보다는 사용하기 좋음.
 		  컬렉션은 데이터들이 필요할 때마다 만들어짐.
 		  구조를 이해하기 는 어려운데, 사용이 편리함.
 		  
==============================

	Map 계열 컬렉션 ( 키와 값은 쌍으로 함께 다님)
	- Map 컬렉션은 키(Key)와 값(value)으로 구성된 'Entry 객체를 저장'하는 구조를 가지고 있음.
	- 키는 중복 저장 될 수 없지만, 값은 중복 저장이 가능함.
	
	Map 계열 주요 메서드
	
	- 객체 추가 기능
	1. put ( K key, V value) 			 	키와 밸류 타입에 맞춰 작성 - 주어진 키와 값을 추가, 정상적으로 저장되면 그 값(value)을 리턴
	 		
	- 객체 검색 기능
	1. containsKey(Object key)			주어진 키가 있는지 여부 확인
	2. containsValue(Object value)		주어진 값이 있는지 여부 확인
	3. get(Object key)						주어진 키에 들어있는 값을 반환
	4. isEmpty()								컬렉션이 비어있는지 여부를 확인
	5. size()									저장된 키의 총 수를 리턴
	6. values()								저장된 모든 값을 컬렉션(List)에 담아서 리턴
	7. keySet()								저장된 모든 키를 Set객체에 담아서 리턴
	8. entrySet()								키와 값을 쌍으로 구성된 모든 Entry객체를 Set에 담아서 리턴
												반환 타입 형태 : Set<Map.Entry<K,V>> (<- 엔트리 타입)
	- 객체 삭제 기능
	1. clear()									모든 Entry 삭제
	2. remove(Object key)					주어진 키와 일치하는 Entry 객체를 삭제
								
	  
 		  
 		  
		linked list는 스택처럼 보면됨 / 그러나 스택은 아니라는 사실을 명심하자
 		  
 		  push pop stack에서 사용 
 		  queue 
 		  
 		  
 		컬렉션은 타입 사용하려면 wrapper 씌워서 사용해야 함!!!
 		
 		객체끼리 비교해서 정렬할 기준값이 필요
 		
 		